/*
 * Copyright (C) 2023 Florian Sansou <florian.sansou@enac.fr>
 *
 * This file is part of paparazzi
 *
 * paparazzi is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * paparazzi is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with paparazzi; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

/** @file "modules/ctrl/eff_scheduling_colibri.c"
 * @author Florian Sansou <florian.sansou@enac.fr>
 * Interpolation of control effectivenss matrix of the Colibri.
 */

#include "modules/ctrl/eff_scheduling_colibri.h"
#include "firmwares/rotorcraft/stabilization/stabilization_indi.h"
#include "firmwares/rotorcraft/guidance/guidance_h.h"
#include "state.h"

#include "modules/datalink/downlink.h"

// Airspeed at which only with motor
#ifndef INDI_SCHEDULING_LOW_AIRSPEED
#define INDI_SCHEDULING_LOW_AIRSPEED 4.0
#endif



#if INDI_NUM_ACT < 6
#error "This module works with Colibri with 8 actuators by only 6 are managed by INDI "
#endif

static float g1g2_hover[INDI_OUTPUTS][INDI_NUM_ACT] = {STABILIZATION_INDI_G1_ROLL,
                                                STABILIZATION_INDI_G1_PITCH, STABILIZATION_INDI_G1_YAW, STABILIZATION_INDI_G1_THRUST
                                               };

void ctrl_eff_scheduling_init(void)
{
  for (int8_t i = 0; i < INDI_OUTPUTS; i++) {
    for (int8_t j = 0; j < INDI_NUM_ACT; j++) {
        g1g2[i][j] = g1g2_hover[i][j] / INDI_G_SCALING;
    }
  }
}


void ctrl_eff_scheduling_periodic(void){
  
  // freq = 20.0 Hz

  /*
  float ratio = 1/(INDI_SCHEDULING_HIGH_AIRSPEED - INDI_SCHEDULING_LOW_AIRSPEED)*airspeed - INDI_SCHEDULING_LOW_AIRSPEED/(INDI_SCHEDULING_HIGH_AIRSPEED - INDI_SCHEDULING_LOW_AIRSPEED);

  Bound(ratio,0.0,1.0);

  int8_t i;
  int8_t j;
  for (i = 0; i < INDI_OUTPUTS; i++) {
    for (j = 0; j < 4; j++) {
       // Motor
      g1g2[i][j] = g_hover[i][j] * (1.0 - ratio) + g_forward[i][j] * ratio;
    }
  }
  */

 
  

  // calculate squared airspeed
  float airspeed = stateGetAirspeed_f();

  if(airspeed>INDI_SCHEDULING_LOW_AIRSPEED){
    airspeed -= INDI_SCHEDULING_LOW_AIRSPEED; //offset for start eff at zero!
    struct FloatEulers eulers_zxy;
    float_eulers_of_quat_zxy(&eulers_zxy, stateGetNedToBodyQuat_f());

    float pitch_ratio = 0.0;
    if (eulers_zxy.theta > -M_PI_4) {
      pitch_ratio = 0.0;
    } 
    else {
      pitch_ratio = fabs(1.0 - eulers_zxy.theta/(-M_PI_4));
    }
    Bound(pitch_ratio,0.0,1.0);


    Bound(airspeed, 0.0, 30.0);
    float airspeed2 = airspeed*airspeed;

    
    //float roll_eff = CE_ROLL_A*airspeed2;
    //g1g2[0][4] = -roll_eff/1000;
    //g1g2[0][5] =  roll_eff/1000;
    

    g1g2[0][4] = 0;
    g1g2[0][5] = 0;

    float pitch_eff = pitch_ratio * CE_PITCH_A * airspeed2;
    g1g2[1][4] = -pitch_eff/1000; // elevon_left
    g1g2[1][5] =  pitch_eff/1000; // elevon_right

    float yaw_eff = pitch_ratio * CE_YAW_A * airspeed2;
    g1g2[2][4] = -yaw_eff/1000; // elevon_left
    g1g2[2][5] = -yaw_eff/1000; // elevon_right

    // No thrust generated by elevon, maybe take drag in accout for the future ?
    g1g2[3][4] = 0; 
    g1g2[3][5] = 0;
  }
  else{
    //Come back to motor control
    g1g2[0][4] = 0; // elevon_left
    g1g2[0][5] = 0; // elevon_right

    g1g2[1][4] = 0; // elevon_left
    g1g2[1][5] = 0; // elevon_right

    g1g2[2][4] = 0; // elevon_left
    g1g2[2][5] = 0; // elevon_right

   
    g1g2[3][4] = 0; // elevon_left
    g1g2[3][5] = 0; // elevon_right
  }
  
}

extern void ctrl_eff_scheduling_report(void){
  //float f[4] = { g1g2_forward[0][0], g1g2_forward[1][0], g1g2_forward[2][0], g1g2_forward[3][0]};
  //g1g2[1][0], g1g2[1][1], g1g2[1][2], g1g2[1][3], g1g2[1][4], g1g2[1][5],
  //g1g2[2][0], g1g2[2][1], g1g2[2][2], g1g2[2][3], g1g2[2][4], g1g2[2][5],
  //g1g2[3][0], g1g2[3][1], g1g2[3][2], g1g2[3][3], g1g2[3][4], g1g2[3][5]
  
  float f[6] = { g1g2[0][0], g1g2[0][1], g1g2[0][2], g1g2[0][3], g1g2[0][4], g1g2[0][5]};
  DOWNLINK_SEND_PAYLOAD_FLOAT(DefaultChannel, DefaultDevice, 6, f); 

}
